stages:
  - prepare
  - sast_scan
  - test
  - build
  - security
  - dast_scan
  # - deploy
  # - update-deployment-manifest
  # - update-k8s-manifest
  # - slack_notify
  # - clean_up

image: node:23-bookworm-slim

cache:
  paths:
    - node_modules/

# ---- PREPARE ----
install_dependencies:
  stage: prepare
  tags:
    - linux-homelab-general-vm
  script:
    - npm ci --ignore-scripts
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour

# ---- ESLINT ----
# eslint:
#   stage: sast_scan
#   script:
#     - npm run lint
#   when: always

# ---- GITLEAKS SCAN ----
# gitleaks_scan:
#   stage: sast_scan
#   tags:
#     - linux-homelab-general-vm
#   image: 
#     name: zricethezav/gitleaks:latest
#     entrypoint: [""]
#   script:
#     - gitleaks detect --source . --exit-code 1 --no-git --redact --report-path gitleaks-report.json
#   artifacts:
#     paths:
#       - gitleaks-report.json
#     when: always
#   allow_failure: false
  # rules:
  #   - if: '$CI_COMMIT_BRANCH == "main"'
  #   - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# ---- DEPENDENCY AUDIT ----
# npm_audit:
#     stage: sast_scan
#     script:
#         - npm audit --audit-level=moderate
#     allow_failure: false

# ---- SONARCLOUD ----
# This job runs the SonarCloud analysis. It requires the `SONAR_TOKEN` variable
# sonarcloud-check:
#   image:
#     name: sonarsource/sonar-scanner-cli:latest
#     entrypoint: [""]
#   cache:
#     key: "${CI_JOB_NAME}"
#     paths:
#       - .sonar/cache
#   stage: sast_scan
#   script:
#     - echo 'sonarqube'
#     - sonar-scanner
#   only:
#     - merge_requests
#     - main

# ---- TEST ----
# unit_test:
#   stage: test
#   script:
#     - npm run test
#   needs: [install_dependencies]

# playwright_test:
#   stage: test
#   image: mcr.microsoft.com/playwright:v1.54.0-noble
#   before_script:
#     - npx playwright install chrome
#   script:
#     - npm run playwright --reporter=html --output=playwright-report
#   needs: [install_dependencies]
#   artifacts:
#     when: always
#     paths:
#       - playwright-report/
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"'

# ---- BUILD IMAGE ----
# docker_build:
#     stage: build
#     image: docker:latest
#     services:
#         - docker:dind
#     variables:
#       DOCKER_NAME: 'cheulong/movies-finder-frontend'
#       DOCKER_IMAGE: $CI_REGISTRY_IMAGE
#       DOCKER_TAG: $CI_COMMIT_SHORT_SHA
#       DOCKER_HOST: tcp://docker:2375
#       DOCKER_TLS_CERTDIR: ""
#     script:
#       - docker info  # check connection
#       - echo $CI_REGISTRY_PASSWORD | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
#       - docker build -f Dockerfile.prod -t $DOCKER_IMAGE:$DOCKER_TAG .
#       - docker push $:$DOCKER_TAG
    # only:
    #     - main

# ---- TRIVY SCAN ----
# This job runs the Trivy security scanner against the Docker image and filesystem.
# trivy_scan:
#   image:
#     name: aquasec/trivy:latest
#     entrypoint: [""]
#   stage: security
#   variables:
#       DOCKER_NAME: 'cheulong/movies-finder-frontend'
#       DOCKER_IMAGE: $CI_REGISTRY_IMAGE
#       DOCKER_TAG: $CI_COMMIT_SHORT_SHA
#   script:
#     - trivy image --exit-code 1 --severity HIGH,CRITICAL --output trivy-report.json $DOCKER_IMAGE:$DOCKER_TAG
#   allow_failure: false
#   needs: [docker_build]
  # rules:
  #   - if: '$CI_COMMIT_BRANCH == "main"'
  # artifacts:
  #   paths:
  #     - trivy-report.json
  #   when: always

# ---- SYFT SBOM ----
# This job generates a Software Bill of Materials (SBOM) using Syft.
# syft_sbom:
#   image:
#     name: docker:latest
#   stage: security
#   variables:
#     DOCKER_NAME: 'cheulong/movies-finder-frontend'
#     DOCKER_IMAGE: $CI_REGISTRY_IMAGE
#     DOCKER_TAG: $CI_COMMIT_SHORT_SHA
#     DOCKER_HOST: tcp://docker:2375
#     DOCKER_TLS_CERTDIR: ""
#   services:
#         - docker:dind
#   needs: [docker_build]
#   before_script:
#     # Login to GitLab Container Registry to pull the image
#     - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
#     - docker pull $DOCKER_IMAGE:$DOCKER_TAG
#     - apk add --no-cache curl bash
#     - curl -sSfL https://get.anchore.io/syft | sh -s -- -b /usr/local/bin
#   script:
#     - syft --version
#     - syft $DOCKER_IMAGE:$DOCKER_TAG -o spdx-json > sbom.spdx.json
#   artifacts:
#     paths:
#       - sbom.spdx.json
#   when: always
#   allow_failure: true
  # rules:
  #   - if: '$CI_COMMIT_BRANCH == "main"'

# ---- GRYPE SCAN ----
# This job runs the Grype vulnerability scanner against the SBOM generated by Syft.
# grype_scan:
#   image:
#     name: alpine:latest
#   stage: security
#   needs: [syft_sbom]
#   before_script:
#     - apk add --no-cache curl bash
#     - curl -sSfL https://get.anchore.io/grype | sh -s -- -b /usr/local/bin
#   script:
#     - grype sbom:sbom.spdx.json --fail-on high

# ---- RUN APP ----
# This job runs the application using Docker Compose.
run_app:
  stage: dast_scan
  image:
    name: docker:latest
  # needs:
  #   - job: docker_build
  variables:
    DOCKER_NAME: 'cheulong/movies-finder-frontend'
    DOCKER_IMAGE: $CI_REGISTRY_IMAGE
    DOCKER_TAG: $CI_COMMIT_SHORT_SHA
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  services:
    - name: docker:dind
      alias: docker

  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
    - docker pull $DOCKER_IMAGE:e4ac7b2b
  script:
    - docker run --rm -d -p 80:80 $DOCKER_IMAGE:e4ac7b2b
    - sleep 15  # wait for app to start
# ---- OWASP ZAP ----
# This job runs the OWASP ZAP security scanner against the application.
owap_zap:
    stage: dast_scan
    image: zaproxy/zap-stable
    allow_failure: true
    services:
    - name: $DOCKER_IMAGE:e4ac7b2b
      alias: app
    variables:
      DOCKER_NAME: 'cheulong/movies-finder-frontend'
      DOCKER_IMAGE: $CI_REGISTRY_IMAGE
    before_script:
    - mkdir -p /zap/wrk
    script:
        - echo 'owap zap'
        # - curl http://127.0.0.1:80/ # Ensure the app is running
        - zap-baseline.py -t http://app:80 -g gen.conf -r zap-report.html
        - cp /zap/wrk/zap-report.html .
        # full scan: zap-full-scan.py
        # api scan: zap-api-scan.py
    needs:
      - job: run_app
    artifacts:
        expire_in: "30 days"
        when: always
        reports:
          dast: zap-report.html
        paths:
          - zap-report.html
    # only:
    # - main


# ---- DEPLOY IMAGE ----
# deploy_image:
#     stage: deploy
#     image: docker:latest
#     services:
#         - docker:dind
#     variables:
#       DOCKER_NAME: 'cheulong/movies-finder-frontend'
#       DOCKER_IMAGE: $CI_REGISTRY_IMAGE
#       DOCKER_TAG: $CI_COMMIT_SHORT_SHA
#       DOCKER_HOST: tcp://docker:2375
#       DOCKER_TLS_CERTDIR: ""
#     script:
#         - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
#         - docker pull $DOCKER_IMAGE:$DOCKER_TAG
#         - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-
#         - docker push $DOCKER_IMAGE:$DOCKER_TAG
#     only:
#         - main

# ---- UPDATE MANIFEST REPO ----
# update_manifest_repo:
#   stage: update-deployment-manifest
#   image: alpine/git
#   needs:
#     - update_manifest_repo
#   script:
#     - apk add --no-cache git
#     - git config --global user.email "ci-bot@example.com"
#     - git config --global user.name "CI Bot"
#     - git clone https://gitlab.com/your-group/k8s-manifest-repo.git
#     - cd k8s-manifest-repo
#     # e.g., update image tag in deployment.yaml
#     - sed -i "s|image: your-image:.*|image: your-image:$CI_COMMIT_SHORT_SHA|" deployment.yaml
#     - git add deployment.yaml
#     - git commit -m "Update deployment image tag to $CI_COMMIT_SHORT_SHA"
#     - git push https://$CI_JOB_TOKEN@gitlab.com/your-group/k8s-manifest-repo.git HEAD:main
#   only:
#     - main
#   when: on_success

# ---- SLACK NOTIFY ----
# slack_notify:
#     stage: slack_notify
#     script:
#         - curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"Pipeline finished for commit $CI_COMMIT_SHORT_SHA\"}" "$SLACK_WEBHOOK"
#     when: always
# build:
#     stage: build
#     script:
#         - echo 'build'

# --- Clean up ---
# clean_up:
#   stage: clean_up
#   script:
#     - echo "Cleaning up temporary files"
#     - rm -rf node_modules/
#   when: always
#   allow_failure: true

# # ---- BUILD ----
# build:
#     stage: build
#     image: node:20
#     script:
#         - npm run build
#     needs: [install_dependencies]
#     artifacts:
#         paths:
#             - dist/
#         expire_in: 1 hour

# ---- SECURITY ----
# owap_zap:
#     stage: security
#     image: zaproxy/zap-stable
#     allow_failure: true
#     before_script:
#     - mkdir -p /zap/wrk
#     script:
        
#         - echo 'owap zap'
#         - zap-baseline.py -t http://172.0.0.1:5173/ -g gen.conf -r zap-report.html
#         - cp /zap/wrk/zap-report.html .
        # full scan: zap-full-scan.py
        # api scan: zap-api-scan.py
    # needs:
    #   - job: install_dependencies
    # artifacts:
    #     expire_in: "30 days"
    #     when: always
    #     reports:
    #       dast: zap-report.html
    #     paths:
    #       - zap-report.html
    # only:
    # - main










# deploy_staging:
#     stage: deploy
#     script:
#         - echo "Deploying to staging"
#         - kubectl set image deployment/node-app node=$DOCKER_IMAGE --record
#     environment:
#         name: staging
#         url: https://staging.example.com
#     only:
#         - main
#     when: manual # Optional approval step

# deploy_prod:
#     stage: deploy
#     script:
#         - echo "Deploying to production"
#         - kubectl set image deployment/node-app node=$DOCKER_IMAGE --record
#     environment:
#         name: production
#         url: https://example.com
#     only:
#         - tags
#     when: manual



# # unit_test:
# #     stage: test
# #     script:
# #         - echo 'test'

# # build_image:
# #     stage: package
# #     script:
# #         - echo 'build image'

# # trivy:
# #     stage: package
# #     script:
# #         - echo 'scan image'
# #     needs:
# #         - job: build_image

# # deploy_dev:
# #     stage: deploy_dev
# #     script:
# #         - echo "dev"
# #         - mkdir build
# #     environment: dev
# #     artifacts:
# #         paths:
# #             - build/
# #         expire_in: 2 weeks
# #     only:
# #         - main
# #         - tags

# # deploy_staging:
# #     stage: deploy_staging
# #     script: echo "staging"
# #     environment: staging
# #     when: manual
# #     only:
# #         - main

# # deploy_prod:
# #     stage: deploy_prod
# #     script: echo "prod"
# #     environment: prod
# #     when: manual
# #     only:
# #         - main

