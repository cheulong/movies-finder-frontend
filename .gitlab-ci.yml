stages:
  - prepare
  - sast_scan
  # SAST_SCANS
  # - gitleaks_scan
  # - eslint
  # - npm_audit
  # - dependency_check
  # - sonarcloud-check
  # TESTS
  - test
  # BUILD_IMAGE
  - build
  - security
  # SBOM_SCANS
  # - syft_sbom
  # - grype_scan
  # DAST_SCANS
  # - trivy_scan
  # - owap_zap
  # - snyk_scan

  # - run_app

  # - deploy_image
  # - update-k8s-manifest
  # - slack_notify
  # - clean_up

image: node:23-bookworm-slim

cache:
  paths:
    - node_modules/

# ---- PREPARE ----
install_dependencies:
  stage: prepare
  tags:
    - linux-homelab-general-vm
  script:
    - npm ci --ignore-scripts
    # - npm run dev & # Start the app in the background
    # - sleep 10 # Wait for the app to start (optional, adjust as needed
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour

# ---- ESLINT ----
eslint:
  stage: sast_scan
  script:
    - npm run lint
  when: always

# ---- GITLEAKS SCAN ----
gitleaks_scan:
  stage: sast_scan
  tags:
    - linux-homelab-general-vm
  image: 
    name: zricethezav/gitleaks:latest
    entrypoint: [""]

  script:
    - gitleaks detect --source . --exit-code 1 --no-git --redact --report-path gitleaks-report.json
  artifacts:
    paths:
      - gitleaks-report.json
    when: always
  allow_failure: false
  # rules:
  #   - if: '$CI_COMMIT_BRANCH == "main"'
  #   - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'




# ---- DEPENDENCY AUDIT ----
npm_audit:
    stage: sast_scan
    script:
        - npm audit --audit-level=moderate
    allow_failure: false


# -- DEPENDENCY CHECK ----
# This job runs the OWASP Dependency Check tool to scan for vulnerabilities in dependencies.
# dependency_check:
#   image:
#     name: owasp/dependency-check:latest
#     entrypoint: [""]
#   stage: dependency_check
#   script:
#     - mkdir -p dependency-check-report
#     - ls
#     - /usr/share/dependency-check/bin/dependency-check.sh --project "my-project" --scan . --format "HTML" --out dependency-check-report --failOnCVSS 7
#     - ls -R dependency-check-report
#   artifacts:
#     paths:
#       - dependency-check-report/
#     when: always

# ---- SONARCLOUD ----
# This job runs the SonarCloud analysis. It requires the `SONAR_TOKEN` variable
# to be set in the CI/CD settings of your project.
# The `sonarcloud-check` job is paused for now, as per the TODO comment
# TODO: pause for now
sonarcloud-check:
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  stage: sast_scan
  script:
    - echo 'sonarqube'
    - sonar-scanner
#   only:
#     - merge_requests
#     - main



# ---- TEST ----
unit_test:
  stage: test
  script:
    - npm run test
  needs: [install_dependencies]

playwright_test:
  stage: test
  image: mcr.microsoft.com/playwright:v1.54.0-noble
  before_script:
    - npx playwright install chrome
  script:
    - npm run playwright --reporter=html --output=playwright-report
  needs: [install_dependencies]
  artifacts:
    when: always
    paths:
      - playwright-report/
      
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"'

# ---- SNYK SCAN ----
# This job runs the Snyk security scanner against the project.
# snyk_scan:
#     image: 
#       name: snyk/snyk:docker
#       entrypoint: [""]
#     stage: security
#     script:
#       - snyk auth $SNYK_TOKEN
#       - snyk test --all-projects --json-file-output=report.json
#     artifacts:
#         paths:
#           - report.json
#         when: always
#     only:
#         - merge_requests
#         - main
#     allow_failure: true # Optional: avoid blocking MR if test fails

# ---- BUILD IMAGE ----
docker_build:
    stage: build
    image: docker:latest
    services:
        - docker:dind
    variables:
      DOCKER_NAME: 'cheulong/movies-finder-frontend'
      DOCKER_IMAGE: $CI_REGISTRY_IMAGE
      DOCKER_TAG: $CI_COMMIT_SHORT_SHA
      DOCKER_HOST: tcp://docker:2375
      DOCKER_TLS_CERTDIR: ""
    script:
      - docker info  # check connection
      - echo $CI_REGISTRY_PASSWORD | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
      - docker build -f Dockerfile.prod -t $DOCKER_IMAGE:$DOCKER_TAG .
      - docker push $DOCKER_IMAGE:$DOCKER_TAG

    # only:
    #     - main

# ---- TRIVY SCAN ----
# This job runs the Trivy security scanner against the Docker image and filesystem.
trivy_scan:
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  stage: security
  variables:
      DOCKER_NAME: 'cheulong/movies-finder-frontend'
      DOCKER_IMAGE: $CI_REGISTRY_IMAGE
      DOCKER_TAG: $CI_COMMIT_SHORT_SHA
  script:
    - trivy image --exit-code 1 --severity HIGH,CRITICAL --output trivy-report.json $DOCKER_IMAGE:$DOCKER_TAG
    # - trivy fs --exit-code 1 --severity HIGH,CRITICAL --output trivy-report.json .
    # - trivy config  --exit-code 1 --output trivy-report.json <my-docker-image:latest>
  allow_failure: false
  needs: [docker_build]
  # rules:
  #   - if: '$CI_COMMIT_BRANCH == "main"'
  artifacts:
    paths:
      - trivy-report.json
    when: always

# ---- SYFT SBOM ----
# This job generates a Software Bill of Materials (SBOM) using Syft.
syft_sbom:
  image:
    name: docker.io/anchore/syft:debug
    entrypoint: [""]
  stage: security
  variables:
    DOCKER_NAME: 'cheulong/movies-finder-frontend'
    DOCKER_IMAGE: $CI_REGISTRY_IMAGE
    DOCKER_TAG: $CI_COMMIT_SHORT_SHA
  needs: [docker_build]
  services:
    - docker:dind
  before_script:
    # Login to GitLab Container Registry to pull the image
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
    - docker pull $DOCKER_IMAGE:$DOCKER_TAG
  script:
    - /syft --version
    - /syft $DOCKER_IMAGE:$DOCKER_TAG -o spdx-json > sbom.spdx.json
    - /syft $DOCKER_IMAGE:$DOCKER_TAG -o cyclonedx-json > sbom-cyclonedx.json
  artifacts:
    paths:
      - sbom.spdx.json
      - sbom-cyclonedx.json
  when: always
  allow_failure: true
  # rules:
  #   - if: '$CI_COMMIT_BRANCH == "main"'

# ---- GRYPE SCAN ----
# This job runs the Grype vulnerability scanner against the SBOM generated by Syft.
grype_scan:
  image:
    name: anchore/grype:latest
    entrypoint: [""]
  stage: security
  needs: [syft_sbom]
  script:
    - grype sbom:sbom.spdx.json --exit-code 1 --severity HIGH,CRITICAL
    - grype sbom:sbom-cyclonedx.json --exit-code 1 --severity HIGH,CRITICAL

# ---- RUN APP ----
# This job runs the application using Docker Compose.
# run_app:
#   stage: run_app
#   services:
#     - docker:dind
#   image: docker:latest
#   variables:
#     DOCKER_HOST: tcp://docker:2375/
#     DOCKER_DRIVER: overlay2
#   script:
#     - docker compose -f compose.prod.yml up -d
#     - sleep 15  # wait for app to start
#     - docker ps  # List running containers to verify app is up

# ---- OWASP ZAP ----
# This job runs the OWASP ZAP security scanner against the application.
# owap_zap:
#     stage: owap_zap
#     image: zaproxy/zap-stable
#     allow_failure: true
#     before_script:
#     - mkdir -p /zap/wrk
#     script:
        
#         - echo 'owap zap'
#         - zap-baseline.py -t http://172.0.0.1:5173/ -g gen.conf -r zap-report.html
#         - cp /zap/wrk/zap-report.html .
#         full scan: zap-full-scan.py
#         api scan: zap-api-scan.py
#     needs:
#       - job: install_dependencies
#     artifacts:
#         expire_in: "30 days"
#         when: always
#         reports:
#           dast: zap-report.html
#         paths:
#           - zap-report.html
#     only:
#     - main


# ---- DEPLOY IMAGE ----
# deploy_image:
#     stage: deploy_image
#     image: docker:latest
#     services:
#         - docker:dind
#     script:
#         - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
#         - docker push $DOCKER_IMAGE
#     only:
#         - main

# ---- UPDATE MANIFEST REPO ----
# update_manifest_repo:
#   stage: update-k8s-manifest
#   image: alpine/git
#   needs:
#     - update_manifest_repo
#   script:
#     - apk add --no-cache git
#     - git config --global user.email "ci-bot@example.com"
#     - git config --global user.name "CI Bot"
#     - git clone https://gitlab.com/your-group/k8s-manifest-repo.git
#     - cd k8s-manifest-repo
#     # e.g., update image tag in deployment.yaml
#     - sed -i "s|image: your-image:.*|image: your-image:$CI_COMMIT_SHORT_SHA|" deployment.yaml
#     - git add deployment.yaml
#     - git commit -m "Update deployment image tag to $CI_COMMIT_SHORT_SHA"
#     - git push https://$CI_JOB_TOKEN@gitlab.com/your-group/k8s-manifest-repo.git HEAD:main
#   only:
#     - main
#   when: on_success

# ---- SLACK NOTIFY ----
# slack_notify:
#     stage: slack_notify
#     script:
#         - curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"Pipeline finished for commit $CI_COMMIT_SHORT_SHA\"}" "$SLACK_WEBHOOK"
#     when: always
# build:
#     stage: build
#     script:
#         - echo 'build'

# --- Clean up ---
# clean_up:
#   stage: clean_up
#   script:
#     - echo "Cleaning up temporary files"
#     - rm -rf node_modules/
#   when: always
#   allow_failure: true

# # ---- BUILD ----
# build:
#     stage: build
#     image: node:20
#     script:
#         - npm run build
#     needs: [install_dependencies]
#     artifacts:
#         paths:
#             - dist/
#         expire_in: 1 hour

# ---- SECURITY ----
# owap_zap:
#     stage: security
#     image: zaproxy/zap-stable
#     allow_failure: true
#     before_script:
#     - mkdir -p /zap/wrk
#     script:
        
#         - echo 'owap zap'
#         - zap-baseline.py -t http://172.0.0.1:5173/ -g gen.conf -r zap-report.html
#         - cp /zap/wrk/zap-report.html .
        # full scan: zap-full-scan.py
        # api scan: zap-api-scan.py
    # needs:
    #   - job: install_dependencies
    # artifacts:
    #     expire_in: "30 days"
    #     when: always
    #     reports:
    #       dast: zap-report.html
    #     paths:
    #       - zap-report.html
    # only:
    # - main










# deploy_staging:
#     stage: deploy
#     script:
#         - echo "Deploying to staging"
#         - kubectl set image deployment/node-app node=$DOCKER_IMAGE --record
#     environment:
#         name: staging
#         url: https://staging.example.com
#     only:
#         - main
#     when: manual # Optional approval step

# deploy_prod:
#     stage: deploy
#     script:
#         - echo "Deploying to production"
#         - kubectl set image deployment/node-app node=$DOCKER_IMAGE --record
#     environment:
#         name: production
#         url: https://example.com
#     only:
#         - tags
#     when: manual



# # unit_test:
# #     stage: test
# #     script:
# #         - echo 'test'

# # build_image:
# #     stage: package
# #     script:
# #         - echo 'build image'

# # trivy:
# #     stage: package
# #     script:
# #         - echo 'scan image'
# #     needs:
# #         - job: build_image

# # deploy_dev:
# #     stage: deploy_dev
# #     script:
# #         - echo "dev"
# #         - mkdir build
# #     environment: dev
# #     artifacts:
# #         paths:
# #             - build/
# #         expire_in: 2 weeks
# #     only:
# #         - main
# #         - tags

# # deploy_staging:
# #     stage: deploy_staging
# #     script: echo "staging"
# #     environment: staging
# #     when: manual
# #     only:
# #         - main

# # deploy_prod:
# #     stage: deploy_prod
# #     script: echo "prod"
# #     environment: prod
# #     when: manual
# #     only:
# #         - main

